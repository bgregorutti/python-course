\documentclass[10pt]{beamer}


\input{includes}
\input{header}

\begin{document}

\maketitle

\begin{frame}{}
  \centering
  \Large
  \textbf{Partie 4}

  \textbf{Packaging, tests unitaires et qualité de code}
\end{frame}


\section{Rappels}

\begin{frame}[fragile]{Structurer un programme, version simple}

  \begin{block}{Structure en plusieurs fichiers}
    \begin{itemize}
      \item Un ou plusieurs modules contenant les fonctionnalités implémentées
      \item Un programme principal
    \end{itemize}
  \end{block}

\bigskip

\begin{lstlisting}[numbers=none]
my_project/
  - module1.py
  - module2.py
  - main.py
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Structurer un programme, version simple}

  Exemple pour deux fichiers

  \texttt{module1.py}
\begin{lstlisting}[language=python, numbers=none]
import math
import sys

def prod(a, b):
    return a * b

def add(a, b):
    return a + b
\end{lstlisting} 

\texttt{main.py}

\begin{lstlisting}[language=python, numbers=none]
from module1 import add, prod
print(add(1, 2))
print(prod(1, 2))
\end{lstlisting} 
\end{frame}


\begin{frame}[fragile]{Structurer un programme, version simple}

  \begin{block}{Problème !}
    \medskip

    Si les fichiers \texttt{main.py} et \texttt{module1.py} sont dans le même dossier, vous pouvez faire
\begin{lstlisting}[language=bash, numbers=none]
python main.py
\end{lstlisting}

  Sinon, ça ne fonctionnera pas !
  \end{block}
\end{frame}



\section{Packaging}

\begin{frame}[fragile]{Qu'est ce qu'un package ?}

  \begin{block}{Un package python est }
    \medskip
    \begin{enumerate}
      \item un \textcolor{red}{ensemble de modules} organisés en dossiers et sous-dossiers
      \item un moyen de créer des libraries spécifiques à un \textcolor{red}{domaine particulier}
      \item \textcolor{red}{installable} via pip, uv ou poetry
      \item un moyen d'utiliser les fonctionnalités dans \textcolor{red}{un autre package}
    \end{enumerate}

    Par exemple :
    \begin{itemize}
      \item SciPy : dédié au calcul scientifique
      \item NumPy : dédié au calcul numérique et matriciel
      \item Pandas : manipulation de tableaux de données et analyses statistiques
      \item Matplotlib : dédié à la visualisation de données
    \end{itemize}
  \end{block}
  

\end{frame}


\begin{frame}[fragile]{Évolution des outils de packaging}

  \begin{block}{Approche traditionnelle (jusqu'en 2023)}
    \begin{itemize}
      \item \texttt{setup.py} + \texttt{setup.cfg} : configuration complexe
      \item Gestion manuelle des dépendances
      \item Pas de fichier de lock pour la reproductibilité
    \end{itemize}
  \end{block}

  \begin{block}{Approche moderne (2024-2025)}
    \begin{itemize}
      \item \texttt{pyproject.toml} : standard PEP 621
      \item Outils modernes : \textcolor{blue}{Poetry} et \textcolor{blue}{uv}
      \item Gestion automatique des environnements virtuels
      \item Fichiers de lock pour la reproductibilité
      \item Installation ultra-rapide (surtout avec uv)
    \end{itemize}
  \end{block}

\end{frame}


\begin{frame}[fragile]{Structure moderne d'un package}

\begin{lstlisting}[numbers=none]
package_folder/
  - README.md	
  - pyproject.toml
  - src/
    - mypackage/
      - __init__.py
      - mymodule.py
      - mymodule2.py
  - tests/
    - test_mymodule.py
    - test_mymodule2.py
\end{lstlisting}

\begin{block}{Changements clés}
  \begin{itemize}
    \item \texttt{pyproject.toml} remplace \texttt{setup.py} et \texttt{setup.cfg}
    \item Layout \texttt{src/} recommandé pour éviter les imports accidentels
    \item \texttt{tests/} au lieu de \texttt{test/}
  \end{itemize}
\end{block}

\end{frame}


\begin{frame}[fragile]{Fichier \texttt{\_\_init\_\_.py}}
  
  \begin{itemize}
    \item Fichier nécessaire pour importer le dossier en tant que package
    \item Il est en général vide mais il peut contenir des instructions comme par exemple la version du package
  \end{itemize}
\begin{lstlisting}[language=python, numbers=none]
__version__ = "0.1.0"
\end{lstlisting}

\begin{block}{Note}
  Depuis Python 3.3+, les namespace packages permettent de s'en passer dans certains cas, mais il reste recommandé de l'inclure.
\end{block}

\end{frame}


\section{Poetry : le gestionnaire complet}

\begin{frame}[fragile]{Poetry : présentation}

  \begin{block}{Qu'est-ce que Poetry ?}
    \begin{itemize}
      \item Outil complet de gestion de packages Python
      \item Gère les dépendances, l'environnement virtuel et la publication
      \item Utilise \texttt{pyproject.toml} et génère \texttt{poetry.lock}
      \item Résolution automatique des conflits de dépendances
    \end{itemize}
  \end{block}

  \begin{block}{Installation}
\begin{lstlisting}[language=bash, numbers=none]
# Linux/macOS
curl -sSL https://install.python-poetry.org | python3 -

# Windows (PowerShell)
(Invoke-WebRequest -Uri https://install.python-poetry.org `
  -UseBasicParsing).Content | py -
\end{lstlisting}
  \end{block}

\end{frame}


\begin{frame}[fragile]{Poetry : créer un nouveau projet}

\begin{lstlisting}[language=bash, numbers=none]
# Creer un nouveau projet
poetry new mypackage

# Ou initialiser dans un dossier existant
poetry init
\end{lstlisting}

Structure générée :
\begin{lstlisting}[numbers=none]
mypackage/
  - pyproject.toml
  - README.md
  - mypackage/
    - __init__.py
  - tests/
    - __init__.py
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]{Poetry : le fichier \texttt{pyproject.toml}}

\begin{lstlisting}[language=bash, numbers=none, basicstyle=\footnotesize\ttfamily]
[tool.poetry]
name = "mypackage"
version = "0.1.0"
description = "My package description"
authors = ["Votre Nom <email@example.com>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.9"
numpy = "^1.24.0"
pandas = "^2.0.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
black = "^23.0.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
\end{lstlisting}

\end{frame}


















\begin{frame}[fragile]{Poetry : commandes essentielles}

\begin{lstlisting}[language=bash, numbers=none]
# Installer les dependances
poetry install

# Ajouter une dependance
poetry add numpy

# Ajouter une dependance de developpement
poetry add --group dev pytest

# Activer l'environnement virtuel
poetry shell

# Executer une commande dans l'environnement
poetry run python main.py

# Construire le package
poetry build

# Publier sur PyPI
poetry publish
\end{lstlisting}

\end{frame}


\section{uv : la rapidité avant tout}

\begin{frame}[fragile]{uv : présentation}

  \begin{block}{Qu'est-ce que uv ?}
    \begin{itemize}
      \item Outil ultra-rapide écrit en Rust par Astral (créateurs de Ruff)
      \item Remplaçant de pip, pip-tools, virtualenv, poetry
      \item 10-100x plus rapide que les outils traditionnels
      \item Compatible avec \texttt{pyproject.toml}
      \item Gestion unifiée : environnements + dépendances + packaging
    \end{itemize}
  \end{block}

  \begin{block}{Installation}
\begin{lstlisting}[language=bash, numbers=none]
# Linux/macOS
curl -LsSf https://astral.sh/uv/install.sh | sh

# Windows
powershell -c "irm https://astral.sh/uv/install.ps1 | iex"

# Avec pip (si necessaire)
pip install uv
\end{lstlisting}
  \end{block}

\end{frame}


\begin{frame}[fragile]{uv : créer un nouveau projet}

\begin{lstlisting}[language=bash, numbers=none]
# Creer un nouveau projet
uv init mypackage
cd mypackage

# Ou initialiser dans un dossier existant
uv init
\end{lstlisting}

Structure générée :
\begin{lstlisting}[numbers=none]
mypackage/
  - pyproject.toml
  - README.md
  - .python-version
  - src/
    - mypackage/
      - __init__.py
  - tests/
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]{uv : le fichier \texttt{pyproject.toml}}

\begin{lstlisting}[language=bash, numbers=none, basicstyle=\footnotesize\ttfamily]
[project]
name = "mypackage"
version = "0.1.0"
description = "My package description"
authors = [
    {name = "Votre Nom", email = "email@example.com"}
]
readme = "README.md"
requires-python = ">=3.9"
dependencies = [
    "numpy>=1.24.0",
    "pandas>=2.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.4.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]{uv : commandes essentielles}

\begin{lstlisting}[language=bash, numbers=none]
# Creer un environnement virtuel
uv venv

# Installer les dependances
uv sync

# Ajouter une dependance
uv add numpy

# Ajouter une dependance de developpement
uv add --dev pytest

# Executer une commande
uv run python main.py
uv run pytest

# Construire le package
uv build

# Installation locale en mode editable
uv pip install -e .
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]{uv : gestion des versions Python}

  \begin{block}{Une fonctionnalité unique}
    uv peut installer et gérer différentes versions de Python !
  \end{block}

\begin{lstlisting}[language=bash, numbers=none]
# Installer une version de Python
uv python install 3.11

# Lister les versions disponibles
uv python list

# Utiliser une version specifique pour le projet
uv venv --python 3.11

# Specifier dans .python-version
echo "3.11" > .python-version
\end{lstlisting}

\end{frame}


\section{Comparaison et choix d'outil}

\begin{frame}{Poetry vs uv : comparaison}

  \begin{center}
  \begin{tabular}{|l|c|c|}
    \hline
    \textbf{Critère} & \textbf{Poetry} & \textbf{uv} \\
    \hline
    Vitesse & Moyenne & Très rapide \\
    Maturité & Mature (2018) & Récent (2024) \\
    Communauté & Large & Croissante \\
    Gestion Python & Non & Oui \\
    Publication PyPI & Intégrée & Externe \\
    Courbe d'apprentissage & Douce & Très douce \\
    Écosystème & Établi & Émergent \\
    \hline
  \end{tabular}
  \end{center}

  \begin{block}{Recommandation}
    \begin{itemize}
      \item \textbf{Poetry} : projets nécessitant stabilité et publication sur PyPI
      \item \textbf{uv} : développement rapide, projets personnels, workflow moderne
    \end{itemize}
  \end{block}

\end{frame}


\begin{frame}[fragile]{Approche traditionnelle (pour référence)}

  \begin{block}{Avec setup.py et setup.cfg}
    Cette approche reste fonctionnelle mais est considérée comme obsolète
  \end{block}

\begin{lstlisting}[language=bash, numbers=none]
# Installation
python setup.py install  # obsolete
pip install .            # Toujours valide

# Construction
python setup.py sdist    # obsolete
pip install build        # Moderne
python -m build          # Recommande
\end{lstlisting}

  \begin{alertblock}{Note}
    PEP 517 et 518 ont standardisé \texttt{pyproject.toml}. L'utilisation de \texttt{setup.py} seul est découragée depuis 2021.
  \end{alertblock}

\end{frame}


\begin{frame}[fragile]{Workflow recommandé en 2025}

  \begin{enumerate}
    \item Choisir son outil : \texttt{uv} (rapide) ou \texttt{poetry} (complet)
    \item Créer le projet : \texttt{uv init} ou \texttt{poetry new}
    \item Développer avec l'environnement virtuel géré automatiquement
    \item Ajouter des dépendances : \texttt{uv add} ou \texttt{poetry add}
    \item Tester : \texttt{uv run pytest} ou \texttt{poetry run pytest}
    \item Construire : \texttt{uv build} ou \texttt{poetry build}
  \end{enumerate}

  \begin{block}{Avantages}
    \begin{itemize}
      \item Environnements isolés automatiques
      \item Fichiers de lock pour la reproductibilité
      \item Gestion simplifiée des dépendances
      \item Standards modernes (PEP 621)
    \end{itemize}
  \end{block}

\end{frame}


\begin{frame}[fragile]{Exercice pratique}

  \begin{block}{Créer votre premier package moderne}
    \begin{enumerate}
      \item Choisissez uv ou poetry et installez-le
      \item Créez un package \texttt{mathtools} avec :
        \begin{itemize}
          \item Un module \texttt{operations.py} (addition, multiplication)
          \item Un module \texttt{stats.py} (moyenne, variance) utilisant numpy
        \end{itemize}
      \item Ajoutez des tests avec pytest
      \item Construisez le package
    \end{enumerate}
  \end{block}

  \begin{block}{Bonus}
    Comparez le temps d'installation des dépendances entre pip et uv !
  \end{block}

\end{frame}









\section{Tests unitaires}

\begin{frame}[fragile]{Tests unitaires}
  
  \onslide<1->
  \begin{block}{Définition}
    \medskip    
    Un test unitaire est une routine permettant de vérifier le bon fonctionnement d'une fonction du package
  \end{block}

  \onslide<2->
  \begin{exampleblock}{Par exemple}
\begin{lstlisting}[language=python, numbers=none]
def generate(number):
  return np.random.normal(0, 1, number)
\end{lstlisting}
  \end{exampleblock}
  
  \onslide<3->
  Comment tester la function \texttt{generate} ?
  \begin{itemize}
    \item Est-ce que \texttt{generate(10)} est un \texttt{np.array} ?
    \item Est-ce que \texttt{generate(10)} donne la bonne distribution ?
    \item Est-ce que \texttt{len(generate(10))} est effectivement 10 ?
  \end{itemize}
\end{frame}


\begin{frame}[fragile]{Implémenter des tests unitaires}

  \begin{block}{Les clés pour implémenter des tests}
    \medskip

    \begin{enumerate}
      \item<+-> Les fonctions de test sont placées dans un dossier \texttt{test/}
      \item<+->Les fonctions de test utilisent le mot clé ``assert''
\begin{lstlisting}[language=python, numbers=none, morekeywords=assert]
from mypackage.mymodule import generate
def test_generate():
    assert len(generate(10)) == 10
\end{lstlisting}
      \item<+-> Conventions pour les noms des fonctions de test
        \begin{itemize}
          \item<+-> Un \textcolor{blue}{module de test} par module de package.
          
          Ex : pour \textcolor{blue}{tester le module} \texttt{mymodule.py}, le nom du fichier de test sera \texttt{test\_mymodule.py}
          \item<+-> Une \textcolor{red}{fonction de test} par fonction testée. 
          
          Ex : pour \textcolor{red}{tester la fonction} \texttt{generate}, le nom de la fonction de test sera \texttt{test\_generate}
        \end{itemize}
    \end{enumerate}
  \end{block}

\end{frame}

\begin{frame}[fragile]{Exemple}

  Pour tester la fonction
  \begin{overprint}

    \onslide<1>
\begin{lstlisting}[language=python, numbers=none]
def hello(name):
    return f"Hello {name}"
\end{lstlisting}

le test est 
\begin{lstlisting}[language=python, numbers=none]
def test_hello():
    assert hello("python") == "Hello python"
\end{lstlisting}

    \onslide<2>
\begin{lstlisting}[language=python, numbers=none]
def hello(name):
    return f"Hello name"
\end{lstlisting}

le test est 
\begin{lstlisting}[language=python, numbers=none]
def test_hello():
    assert hello("python") == "Hello python"
\end{lstlisting}

\begin{center}
  \includegraphics[width=\textwidth]{img/pytest_error.png}
\end{center}


\end{overprint}

\end{frame}


\begin{frame}{Quelques conseils}
  \begin{block}{Il est important}
    \medskip
    \begin{itemize}
      \item<+-> d'implémenter des modules python \textbf{par thème}
      \item<+-> d'implémenter une fonction par ``fonctionnalité'' et éviter du code trop lourd
      \item<+-> de proscrire la \textbf{duplication de code}
      \item<+-> de tester chaque fonctionnalité en un \textbf{minimum de code}
    \end{itemize}
  \end{block}
\end{frame}


\begin{frame}[fragile]{Outils de tests unitaires : Pytest}
  
  \begin{block}{Deux packages à connaitre}
    \medskip
    \begin{itemize}
      \item<+-> \texttt{pytest} : à la racine du projet, exécuter dans un terminal
\begin{lstlisting}[language=python, numbers=none]
python -m pytest -v
\end{lstlisting}
      \item<+-> \texttt{pytest-cov} : un plugin pour mesurer la couverture des tests
\begin{lstlisting}[language=python, numbers=none]
python -m pytest -v --cov
\end{lstlisting}

  \end{itemize}
  \end{block}
  
  \onslide<3>{
    Le package \texttt{unittest} est également utilisé pour implémenter des tests unitaires avec une syntaxe différente de \texttt{pytest}.
  }
\end{frame}

\begin{frame}{A vous de jouer}

  \begin{block}{Dans votre package}
    \medskip
    \begin{itemize}
      \item Implémentez des tests unitaires pour \textbf{chacune des fonctions}
      \item Exécutez les tests avec \texttt{pytest}
    \end{itemize}
  \end{block}
  
\end{frame}




\section{Qualité de code}

\begin{frame}{PEP8}

  \begin{block}{PEP8 -- Style de code}
    \medskip
    Les Python Enhancement Proposals, ou PEP, sont un ensemble de recommandations liées au langage python.

    La PEP8 définit des conventions \textbf{assez restrictives} de style de code.
  \end{block}

  Page officielle : \url{peps.python.org/pep-0008}

\end{frame}


\begin{frame}[fragile]{Conventions PEP8 à retenir}
  \begin{block}{Longueur des lignes}
    \medskip
    La PEP8 recommande entre 80 et 100 charactères maximum.

    Je recommande \textbf{150 charactères}.
  \end{block}
\end{frame}


\begin{frame}[fragile]{Conventions PEP8 à retenir}
  \begin{block}{Indentation}
    \medskip
    Utiliser une identation à \textbf{4 espaces exactement} et ne pas utiliser de \textbf{tabulation}.
    
    Exemple pour un appel de fonction
\begin{lstlisting}[language=python, numbers=none]
foo = long_function_name(var_one, var_two,
                         var_three, var_four)
\end{lstlisting}

ou bien

\begin{lstlisting}[language=python, numbers=none]
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)
\end{lstlisting}

    Exemple pour la définition d'une liste
\begin{lstlisting}[language=python, numbers=none]
l = [1, 2, 3,
     4, 5, 6]]
\end{lstlisting}
      
  \end{block}
\end{frame}



\begin{frame}[fragile]{Conventions PEP8 à retenir}
  \begin{block}{Blocs de code et retours à la ligne}
    \medskip
    Coder des blocs de code \textbf{cohérents}
    
    Séparés les blocs de code par un \textbf{unique} retour à la ligne.
  \end{block}

  \begin{block}{Encoding et langue}
    \medskip
    Utiliser l'anglais et proscrire les caractères spéciaux (encodage UTF-8)
  \end{block}
\end{frame}


\begin{frame}[fragile]{Conventions PEP8 à retenir}
  \begin{block}{Imports}
    \medskip
    \begin{itemize}
      \item Un import par ligne
      \item Préférer les imports \textbf{absolus}
      \item Ordre des imports : package de la librairie standard, librairies installées puis librairies locales

Par exemple :
\begin{lstlisting}[language=python, numbers=none]
import os
import sys
import time

import numpy as np

import mypackage
\end{lstlisting}
    \end{itemize}
  \end{block}
\end{frame}



\begin{frame}[fragile]{Conventions PEP8 à retenir}
  \begin{block}{Chaîne de charactères}
    \medskip
    Il est possible de définir des chaînes de caractères avec " " ou bien ' '.

    PEP8 ne donne pas de recommandation mais il est important de ne pas utiliser les deux façons de faire (uniformisation du code)
  \end{block}
\end{frame}



\begin{frame}[fragile]{Conventions PEP8 à retenir}
  \begin{block}{``Whitespaces'' dans les expressions}
    \medskip
    Proscrire les `espaces blancs' inutiles dans les situations suivantes
  \end{block}

  Correct :
\begin{lstlisting}[language=python, numbers=none]
spam(ham[1], {eggs: 2})
foo = (0,)
if x == 4: print(x, y); x, y = y, x
spam(1)
dct['key'] = lst[index]
\end{lstlisting}

Incorrect :
\begin{lstlisting}[language=python, numbers=none]
spam( ham[ 1 ], { eggs: 2 } )
bar = (0, )
if x == 4 : print(x , y) ; x , y = y , x
spam (1)
dct ['key'] = lst [index]
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Conventions PEP8 à retenir}
  \begin{block}{``Whitespaces'' dans les expressions (suite)}
    \medskip
    Proscrire les `espaces blancs' inutiles dans les situations suivantes
  \end{block}

  Correct :
\begin{lstlisting}[language=python, numbers=none]
x = 1
y = 2
long_variable = 3
\end{lstlisting}

Incorrect :
\begin{lstlisting}[language=python, numbers=none]
x             = 1
y             = 2
long_variable = 3
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Conventions PEP8 à retenir}
  \begin{block}{``Whitespaces'' dans les expressions (suite)}
    \medskip
    Proscrire les `espaces blancs' inutiles dans les situations suivantes
  \end{block}

  Correct :
\begin{lstlisting}[language=python, numbers=none]
def complex(real, imag=0.0):
    return magic(r=real, i=imag)
\end{lstlisting}

Incorrect :
\begin{lstlisting}[language=python, numbers=none]
def complex(real, imag = 0.0):
    return magic(r = real, i = imag)
\end{lstlisting}
\end{frame}




\begin{frame}[fragile]{Conventions PEP8 à retenir}
  \begin{block}{``Whitespaces'' dans les expressions (suite)}
    \medskip
    MAIS ne pas supprimer tous les espaces blancs, par souci de lisibilité !
  \end{block}

  Correct :
\begin{lstlisting}[language=python, numbers=none]
i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)
\end{lstlisting}

Incorrect :
\begin{lstlisting}[language=python, numbers=none]
i=i+1
submitted +=1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)
\end{lstlisting}
\end{frame}




\begin{frame}[fragile]{Conventions PEP8 à retenir}
  \begin{block}{Docstrings}
    \medskip
    Les docstrings sont des commentaires insérés dans le code, en début de modules ou de fonctions.
    Ils résument ce que fait la fonction et indiquent quels sont les arguments et les valeurs de retour.
  \end{block}

\begin{lstlisting}[language=python, numbers=none]
def sample(n):
    """
    Get a sample from Gaussian distribution

    Args:
        n: the number of desired normal values

    Returns
        A sequence of n Gaussian values
    """
    return normal(0, 1, number)
\end{lstlisting}

  Voir aussi la PEP257 : \url{peps.python.org/pep-0257}
\end{frame}

\begin{frame}{Conventions PEP8 à retenir}
  \begin{block}{Conventions de nommage}
    \medskip
    Il existe différentes façon de nommer en python :
    \begin{itemize}
      \item \texttt{lowercase} ou \texttt{snake\_case}
      \item \texttt{lowercase\_with\_underscores}
      \item \texttt{UPPERCASE}
      \item \texttt{UPPERCASE\_WITH\_UNDERSCORES}
      \item \texttt{CapitalizedWords}
    \end{itemize}
  \end{block}
\end{frame}


\begin{frame}{Conventions PEP8 à retenir}
  \begin{block}{Conventions de nommage}
    \medskip
    Les conventions de nommage sont les suivantes :
    \begin{itemize}
      \item Packages : court, \texttt{lowercase}
      \item Modules : court, \texttt{lowercase} ou \texttt{lowercase\_with\_underscores}
      \item Classes : \texttt{CapitalizedWords}
      \item Variables locales : \texttt{lowercase} ou \texttt{lowercase\_with\_underscores}
      \item Variables globales : \texttt{UPPERCASE} ou \texttt{UPPERCASE\_WITH\_UNDERSCORES}
    \end{itemize}

  \end{block}
\end{frame}



\begin{frame}[fragile]{Package \texttt{pylint}}
  \begin{block}{Analyse de code}
    \medskip
    \texttt{pylint} est un outil permettant de mesurer la qualité de code selon les conventions de la PEP8 et met une note sur 10
  \end{block}

  A la racine de votre package
\begin{lstlisting}[numbers=none]
python -m pylint mypackage
\end{lstlisting}

  ou simplement
\begin{lstlisting}[numbers=none]
python -m pylint mymodule.py
\end{lstlisting}
    
\end{frame}



\begin{frame}[fragile]{Package \texttt{pylint}}
  \begin{block}{Exemple}
    \medskip
      \only<1>{
        \texttt{python -m pylint sequence\_adn.py}
        \begin{center}
          \includegraphics[width=\textwidth]{img/pylint1.png}
        \end{center}
      }

      \only<2>{
        \texttt{python -m pylint sequence\_adn.py --max-line-length=150}
        \begin{center}
          \includegraphics[width=\textwidth]{img/pylint2.png}
        \end{center}
      }
  \end{block}
    
\end{frame}


\end{document}