\documentclass[10pt]{beamer}


\input{includes}
\input{header}

\begin{document}
 
\maketitle

\begin{frame}{}
  \centering
  \Large
  \textbf{Partie 2}

  \textbf{Programmation orientée objet}
\end{frame}

\section{Concepts de la programmation orientée objet}




\begin{frame}{Introduction}

  \begin{block}{En python}
    \medskip
    \begin{itemize}
      \item<+-> Les données sont représentées sous forme d'objets ou par des relations entre les objets
      \item<+-> Chaque objet possède un \textcolor{red}{identifiant}, un \textcolor{blue}{type} et une \textcolor{orange}{valeur}
      \item<+-> L'identifiant d'un objet ne change jamais après sa création et représente l'adresse mémoire où est stockée l'objet
      \item<+-> L'opérateur \texttt{is} compare les identifiants de deux objets
      \item<+-> La fonction \texttt{id} revoie l'entier représentant cet identifiant
    \end{itemize}
  \end{block}

\end{frame}



\begin{frame}{Introduction}

  \begin{block}{Définition}
    \medskip
    En informatique, un objet est un conteneur symbolique qui contient des informations et des mécanismes concernant un sujet

    C'est une sorte d'abstration du monde réel définie par un \textbf{ensemble de caractéristiques} (\underline{attributs} et \underline{méthodes}).
  \end{block}

  \textcolor{blue}{Par exemple, un oiseau est un canard s'il vole comme un canard, s'il cancane comme un canard et s'il nage comme un canard.}
\end{frame}





\begin{frame}{Programmation objet vs procédurale}

  \begin{minipage}[t]{0.48\textwidth}
  \textbf{Programmation procédurale}
  \begin{itemize}
    \item<1-> Basée sur des procédures (séquences d'instructions, appels de fonctions)
    \item<2-> Exécutions étape par étape
    \item<3-> Les données et méthodes sont susceptibles de changer durant l'exécution
  \end{itemize}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.48\textwidth}
  \textbf{Programmation objet}
  \begin{itemize}
    \item<1-> Basée sur des classes
    \item<3-> Les données sont fixées dans la définition même des classes
    \item<4> C'est une manière de stocker de l'information
  \end{itemize}
  \end{minipage}
\end{frame}



\begin{frame}{Concepts de la programmation objet}
  \begin{block}{Concepts abordés dans cette partie}
    \medskip
    \begin{itemize}
      \item<+-> Classe 
      \item<+-> Constructeur, attributs et méthodes 
      \item<+-> Principe d'encapsulation
      \item<+-> Héritage
    \end{itemize}
  \end{block}
\end{frame}






\begin{frame}[fragile]{Classe vs objet}
  \begin{block}{Définition}
    \medskip
    Une classe est un bloc de code définissant l'ensemble des caractéristiques communes à plusieurs objets.\\
    C'est une sorte de plan permettant de créer plusieurs objets.
  \end{block}
\bigskip
\begin{lstlisting}[language=Python, numbers=none]
class Point(): # <--
    def __init__(self, x, y):
        self.x = x
        self.y = y
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]{Contructeur}

  \begin{block}{Définition}
    \medskip

    Le constructeur est une fonction appelée lors de la création de l'objet.
    Elle permet d'allouer la mémoire nécessaire à l'objet et d'initialiser ses attributs.

    \medskip
    Le constructeur est une fonction définie par le mot clé \texttt{\_\_init\_\_}
  \end{block}
\begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y): # <--
        self.x = x
        self.y = y
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]{Instanciation}

  \begin{block}{Définition}
    \medskip
    Une instance de classe est un objet dont le comportement et l'\textbf{état} sont définis dans la classe.

    L'instanciation est l'action de créer un objet à partir d'un modèle (c-à-d la classe) via deux opérations :
    \begin{itemize}
      \item l'\textcolor{red}{allocation} qui consiste à réserver un espace mémoire pour stocker l'objet
      \item l'\textcolor{red}{initialisation} qui consiste à fixer l'\textbf{état} de l'objet par l'appel au constructeur de la classe
    \end{itemize}

  \end{block}
\begin{lstlisting}[language=Python, numbers=none]
point = Point(x=1, y=2)
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Attributs d'instance}

  \begin{block}{Définition}
    \medskip
    Les attributs sont des entités qui définissent les propriétés d'un objet. Dans l'exemple, \texttt{x} et \texttt{y} sont les attributs. Ils sont stockés dans la classe via le mot clé \texttt{self}
  \end{block}

\begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y):
        self.x = x # <--
        self.y = y # <--
\end{lstlisting}

\onslide<2>
\begin{center}
  \boxed{\mbox{On parle d'attribut d'instance}}
\end{center}

Attributs de classe : voir \href{https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables}{ici}

\end{frame}

\begin{frame}[fragile]{Méthodes d'instance}

  \begin{block}{Définition}
    \medskip
    Les sont des fonctions membres d'une classe. Elles permettent d'\textbf{intéragir avec l'état} de l'objet, en particulier le modifier.

  \end{block}
\begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def norm(self): # <--
        return math.sqrt(self.x**2 + self.y**2)
\end{lstlisting}

Méthodes de classe : voir \href{https://www.geeksforgeeks.org/class-method-vs-static-method-python/}{ici}

\end{frame}


\section{Principe d'encapsulation\\Accès et modification d'attributs}

\begin{frame}[fragile]{Principe d'encapsulation : définitions}

  \onslide<1->
  Le principe d'encapsulation est un des concepts fondammentaux en programmation objet. Il s'agit de \textcolor{red}{regrouper des données} dans un objet pour en \textcolor{red}{limiter la manipulation}, qui se fait uniquement par des méthodes dédiées.

  Les méthodes sont ainsi vues comme une \textbf{interface} destinée à l'utilisateur, ou une sorte de couche de protection vis-à-vis de l'accès aux données

  \onslide<2->
  Le principe d'encapsulation est fortement lié à la \textcolor{red}{portée des méthodes} et des attributs (publique, protégée ou privée).
% \textcolor{red}{En programmation, l'encapsulation désigne le regroupement de données avec un ensemble de routines
% qui en permettent la lecture et la manipulation. Ce principe est souvent accompagné du masquage
% de ces données brutes1 afin de s'assurer que l'utilisateur ne contourne pas l'interface qui lui est destinée.
% L'ensemble se considère alors comme une boite noire ayant un comportement et des propriétés spécifiés. L'encapsulation est un pilier de la programmation orientée objet, où chaque classe définit des méthodes
% ou des propriétés pour interagir avec les données membres, mais ce principe peut se rencontrer dans d’autres
% styles de programmation (par exemple la programmation modulaire).}
% convention d'écriture : publique, privé

\end{frame}



\begin{frame}[fragile]{Principe d'encapsulation : définitions}

\begin{block}{Accès et modification des attributs}
\medskip
Selon le principe d'encapsulation, il est nécessaire de définir des méthodes permettant de \textcolor{red}{manipuler les attributs} (accès, modification, suppression).

Par exemple, un attribut privé peut être modifié s'il y a une méthode le permettant.

\onslide<2>
On a en particulier :
\begin{itemize}
  \item les accesseurs (ou getters) : \textcolor{blue}{accès} à un attribut
  \item les mutateurs (ou setters) : \textcolor{blue}{modification} d'un attribut
\end{itemize}
\end{block}

\end{frame}


\begin{frame}[fragile]{Principe d'encapsulation : Accès à un attribut}

\begin{overprint}

\onslide<2>
\textbf{Accès direct}
\medskip
\begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y):
        self.x = x
        self.y = y




point = Point(1, 2)
point.x
\end{lstlisting}

\onslide<3>
\textbf{Accès via} \texttt{getattr}
\medskip
\begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y):
        self.x = x
        self.y = y




point = Point(1, 2)
getattr(point, "x")
\end{lstlisting}


\onslide<4>
\textbf{Accès via une méthode spécifique}
\medskip
\begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def get_x(self):
        return self.x

point = Point(1, 2)
point.get_x()
\end{lstlisting}

\end{overprint}

\end{frame}


\begin{frame}{Principe d'encapsulation : modification d'un attribut}

  \begin{block}{Problème}
    \medskip
    Python \textbf{n'applique pas complètement} le principe d'encapsulation : les attributs et les méthodes ne sont \textcolor{red}{pas réellement privés} et peuvent être modifiés très facilement y compris leur type !
  \end{block}
\end{frame}



\begin{frame}[fragile]{Principe d'encapsulation : modification d'un attribut}

\begin{overprint}

\onslide<2>
\textbf{Modification directe}
\medskip
\begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y):
        self.x = x
        self.y = y






point = Point(1, 2)
point.x += 1
point.x
\end{lstlisting}

\onslide<3>
\textbf{Modification via} \texttt{setattr}
\medskip
\begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y):
        self.x = x
        self.y = y






point = Point(1, 2)
setattr(point, "x", 2)
point.x
\end{lstlisting}


\onslide<4>
\textbf{Modification via une méthode spécifique}
\medskip
\begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def set_x(self, value):


        self.x = value

point = Point(1, 2)
point.set_x(2)
point.x
\end{lstlisting}

\onslide<5>
\textbf{Modification via une méthode spécifique}
\medskip
\begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def set_x(self, value):


        self.x = value

point = Point(1, 2)
point.set_x("azerty")
point.x
\end{lstlisting}

\onslide<6>
\textbf{Modification via une méthode spécifique}
\medskip
\begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def set_x(self, value):
        if type(value) not in [int, float]:
            raise AttributeError("Wrong type")
        self.x = value

point = Point(1, 2)
point.set_x("azerty")
# --> AttributeError: Wrong type
\end{lstlisting}


\end{overprint}

\end{frame}


\begin{frame}{Principe d'encapsulation : modification d'un attribut}
  \begin{block}{Questions :}
    \medskip
    \begin{itemize}
      \item Comment rendre un attribut privé ?
      \item[\textcolor{white}{x}] 
      \item Comment limiter sa manipulation ?
    \end{itemize}
  \end{block}
\end{frame}


\begin{frame}[fragile]{Comment rendre les attributs privés 1/3}

  \textbf{Idée 1 : préfixer le nom avec un ``\_''}
  \bigskip
\begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y):
        self._x = x
        self._y = y
\end{lstlisting}

\begin{overprint}

\onslide<2>
\begin{lstlisting}[language=Python, numbers=none]
>>> point = Point(1, 2)
>>> point._x
???
\end{lstlisting}

\onslide<3>
\begin{lstlisting}[language=Python, numbers=none]
>>> point = Point(1, 2)
>>> point._x
1
\end{lstlisting}
\medskip
\warning L'utilisation de ``\_'' n'est qu'une convention d'écriture !

\end{overprint}

  \end{frame}




\begin{frame}[fragile]{Comment rendre les attributs privés 2/3}

  \textbf{Idée 2 : préfixer le nom avec un ``\_\_''}
  \bigskip

  \begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y):
        self.__x = x
        self.__y = y
\end{lstlisting}

  \begin{overprint}





  \onslide<2>
\begin{lstlisting}[language=Python, numbers=none]
>>> point = Point(1, 2)
>>> point.__x
???
\end{lstlisting}




  \onslide<3>
\begin{lstlisting}[language=Python, numbers=none]
>>> point = Point(1, 2)
>>> point.__x
AttributeError: "Point" object has no attribute "__x"
\end{lstlisting}
  \textcolor{red}{A-t-on vraiment rendu privé l'attribut \texttt{x} ?}

  \end{overprint}

    \end{frame}







\begin{frame}[fragile]{Comment rendre les attributs privés 3/3}

  \textbf{Idée 2 : préfixer le nom avec un ``\_\_'' $\rightarrow$ MAIS}
  \bigskip

  \begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y):
        self.__x = x
        self.__y = y
\end{lstlisting}

  \begin{overprint}

    \onslide<2>
\begin{lstlisting}[language=Python, numbers=none]
>>> point = Point(1, 2)
>>> dir(point)
["_Point__x", "_Point__y", ...]
\end{lstlisting}

  \onslide<3>
\begin{lstlisting}[language=Python, numbers=none]
>>> point = Point(1, 2)
>>> point._Point__x
1
\end{lstlisting}
  \warning \textcolor{red}{L'attribut \texttt{x} n'est pas du tout privé en fait !}

  L'utilisation du préfixe ``\_\_'' n'a fait que \textcolor{red}{renommer} la variable.
  \end{overprint}

  \end{frame}


  \begin{frame}{Principe d'encapsulation : pour résumer}
    \begin{itemize}
      \item Les attributs (et méthodes) ne sont jamais réellement privés
      \item[\textcolor{white}{x}]
      \item Il existe des conventions pour \textcolor{blue}{indiquer le caractère privé}
      \item[\textcolor{white}{x}]
      \item On aimerait un moyen simple de \textbf{rendre des attributs privés}
      \item[\textcolor{white}{x}]
      \item On aimerait un moyen \textbf{d'accéder/modifier} ces attributs simplement
    \end{itemize}
  \end{frame}


\begin{frame}[fragile]{Principe d'encapsulation : \texttt{@property}}

  Le décorateur \texttt{@property} est une autre manière de définir un \textcolor{red}{getter}
  
\begin{lstlisting}[language=Python, numbers=none]
class Point():
  def __init__(self, x, y):
      self.__x = x
      self.__y = y

  @property
  def x(self):
      return self.__x
\end{lstlisting}

L'accès à l'attribut \texttt{\_\_x} se fait par 

\begin{lstlisting}[language=Python, numbers=none]
>>> point = Point(1, 2)
>>> point.x
1
\end{lstlisting}
\end{frame}





\begin{frame}[fragile]{Principe d'encapsulation : \texttt{@property}}

  Le décorateur \texttt{@property} est une autre manière de définir un \textcolor{red}{setter}
  
\begin{lstlisting}[language=Python, numbers=none]
class Point():
    def __init__(self, x, y):
        self.__x = x
        self.__y = y

    @property # getter
    def x(self):
        return self.__x

    @x.setter # setter
    def x(self, value):
        if type(value) not in [int, float]:
            raise AttributeError("Wrong type")
        self.__x = value
\end{lstlisting}

Accès et modification :

\begin{lstlisting}[language=Python, numbers=none]
>>> point.x
>>> point.x = 2
\end{lstlisting}
\end{frame}



\section{Surcharge des opérateurs}

\begin{frame}[fragile]{Surcharge des opérateurs : définition}

  \begin{block}{Rappels de faits}
    \medskip
    \begin{itemize}
      \item En Python, l'opérateur `+' permet d'additionner des entiers, des floats, même concaténer des strings...
      \item Mais il n'a \textcolor{blue}{pas de sens a priori} pour vos objets. La surcharge vous permet de lui apprendre.
    \end{itemize}
  \end{block}

  \begin{center}
    \textit{Donner un sens mathématique aux symboles `+', `-', `*', `/' pour vos propres objets}
  \end{center}

\end{frame}


\begin{frame}{Surcharge des opérateurs}
  \begin{block}{Définition}
    \medskip
    Le mécanisme de surcharge des opérateurs consiste à 
    \begin{itemize}
      \item \textcolor{red}{redéfinir des fonctions ou opérations} déjà définies pour certains types
      \item[\textcolor{white}{x}] 
      \item pour les \textcolor{red}{adapter} à d'autres types d'objets
    \end{itemize}
  \end{block}
\end{frame}


\begin{frame}[fragile]{Surcharge des opérateurs : exemple de la classe \texttt{Complex}}

  \begin{block}{Classe \texttt{Complex}}
    \medskip
    Question : comment coder un nombre complexe ?
    \onslide<2>{
      \medskip
      \begin{itemize}
        \item Attributs : partie réelle, partie immaginaire
        \item[\textcolor{white}{x}] 
        \item Méthodes : addition, multiplication, conjugaison, module, affichage, etc.
      \end{itemize}
    }
  \end{block}
\end{frame}

\begin{frame}[fragile]{Surcharge des opérateurs : exemple de la fonction \texttt{print}}
  \begin{block}{Exemple de la class \texttt{Complex}}
    \medskip
\begin{lstlisting}[language=python, numbers=none]
class Complex():
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    def __add__(self, other): # operateur +
        return ???


    def __str__(self): # affichage
        return ???

c = Complex(1, 2)
print(c)
print(c + c)
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{Surcharge des opérateurs : exemple de la fonction \texttt{print}}
  \begin{block}{Exemple de la class \texttt{Complex}}
    \medskip
\begin{lstlisting}[language=python, numbers=none]
class Complex():
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    def __add__(self, other): # operateur +
        return Complex(real=self.real + other.real, 
                       imag=self.imag + other.imag)

    def __str__(self): # affichage
        return f"{self.real} + {self.imag}i"

c = Complex(1, 2)
print(c)
print(c + c)
\end{lstlisting}
\end{block}
\end{frame}


\begin{frame}{Quels sont les opérateurs concernés (1/2)}

  \small
  \centering
  \begin{tabular}{lcc}
    \hline
    \textbf{Opérateur} & \textbf{Expression} & \textbf{Interprétation Python} \\
    \hline
    \hline
    Addition & p1 + p2 & p1.\_\_add\_\_(p2) \\
    \hline
    Soustration & p1 - p2 & p1.\_\_sub\_\_(p2) \\
    \hline
    Multiplication & p1 * p2 & p1.\_\_mul\_\_(p2) \\
    \hline
    Puissance & p1 ** p2 & p1.\_\_pow\_\_(p2) \\
    \hline
    Division & p1 / p2 & p1.\_\_truediv\_\_(p2) \\
    \hline
    Division entière & p1 // p2 & p1.\_\_floordiv\_\_(p2) \\
    \hline
    Modulo & p1 \% p2 & p1.\_\_mod\_\_(p2) \\
    \hline
    ET binaire & p1 \& p2 & p1.\_\_and\_\_(p2) \\
    \hline
    OU binaire & p1 \texttt{|} p2 & p1.\_\_or\_\_(p2) \\
    \hline
  \end{tabular}
\end{frame}


\begin{frame}{Quels sont les opérateurs concernés (2/2)}

  \small
  \centering
  \begin{tabular}{lcc}
    \hline
    \textbf{Opérateur} & \textbf{Expression} & \textbf{Interprétation Python} \\
    \hline
    \hline
    Inférieur à & p1 \texttt{<} p2 & p1.\_\_lt\_\_(p2) \\
    \hline
    Inférieur ou égal & p1 \texttt{<=} p2 & p1.\_\_le\_\_(p2) \\
    \hline
    Egal & p1 \texttt{==} p2 & p1.\_\_eq\_\_(p2) \\
    \hline
    Différent & p1 \texttt{!=} p2 & p1.\_\_ne\_\_(p2) \\
    \hline
    Supérieur à & p1 \texttt{>} p2 & p1.\_\_gt\_\_(p2) \\
    \hline
    Supérieur ou égal & p1 \texttt{>=} p2 & p1.\_\_ge\_\_(p2) \\
    \hline
  \end{tabular}  
\end{frame}

\section{Héritage}

\begin{frame}[fragile]{Définition}

  \begin{itemize}
    \item L'héritage est un mécanisme qui nous permet de créer une nouvelle classe à partir d'une classe existante, en ajoutant de \textcolor{blue}{nouveaux attributs et méthodes}
    \item La nouvelle classe est appelée \textcolor{red}{classe fille} et la classe existante, \textcolor{red}{classe mère}
    \item On dit que la classe fille ``hérite de'' ou  ``étend'' la classe mère
  \end{itemize}

\begin{lstlisting}[language=python, numbers=none]
class mere:
  # corps de la classe mere

class fille(mere):
  # corps de la classe fille
\end{lstlisting}

\end{frame}




\begin{frame}{Exemple : Gestion des personnes à l'Université}
  \begin{center}
    \includegraphics[width=0.8\textwidth]{img/heritage.png}
  \end{center}
\end{frame}

\begin{frame}[fragile]{Exemple : Gestion des personnes à l'Université}

  \textbf{Sans héritage, deux classes indépendantes}

\begin{lstlisting}[language=python, numbers=none]
class Person():
    def __init__(self, firstname, lastname):
        self.firstname = firstname
        self.lastname = lastname
\end{lstlisting}

\begin{lstlisting}[language=python, numbers=none]
class Student():
    def __init__(self, firstname, lastname, university):
        self.firstname = firstname
        self.lastname = lastname
        self.university = university
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Exemple : Gestion des personnes à l'Université}

  \textbf{Sans héritage, deux classes indépendantes}

\begin{lstlisting}[language=python, numbers=none]
class Person():
    def __init__(self, firstname, lastname):
        self.firstname = firstname
        self.lastname = lastname
\end{lstlisting}

\begin{lstlisting}[language=python, numbers=none]
class Student():
    def __init__(self, firstname, lastname, university):


        self.university = university
\end{lstlisting}
  \end{frame}


\begin{frame}[fragile]{Exemple : Gestion des personnes à l'Université}

  \textbf{Avec héritage fonction \texttt{super}}
\begin{lstlisting}[numbers=none, morekeywords={Person, super}]
class Person():
    def __init__(self, firstname, lastname):
        self.firstname = firstname
        self.lastname = lastname
\end{lstlisting}

\begin{lstlisting}[numbers=none, morekeywords={Person, super}]
class Student(Person):
    def __init__(self, firstname, lastname, university):
        super().__init__(firstname, lastname)

        self.university = university        
\end{lstlisting}
  \end{frame}

\section{Ce qu'il faut retenir}

\begin{frame}{Ce qu'il faut retenir de la programmation objet 1/2}

  \begin{itemize}
    \item C'est un concept central en python : \textcolor{red}{tout est objet}
    \item Elle est équivalente à définir des \textcolor{red}{types}
    \item C'est un manière de \textcolor{red}{stocker de l'information}
    \item Les attributs et les méthodes sont systématiquement \textcolor{red}{publiques}
    \item Il est possible de \textcolor{red}{surcharger} des opérateurs mathématiques (somme, produit, opérateurs logiques, etc.) pour des types non standards
    \item L'héritage permet de partager des attributs et des méthodes entre plusieurs objets et éviter la \textcolor{red}{duplication de code}
  \end{itemize}
\end{frame}



\begin{frame}{Ce qu'il faut retenir de la programmation objet 2/2}

  Exemples pratiques en ML :
  
  \bigskip
  
  \textbf{Data loader en traitement de l'image}

    \href{https://keras.io/examples/vision/oxford_pets_image_segmentation/}{keras.io/examples/vision/oxford\_pets\_image\_segmentation}

  \bigskip

  \textbf{Définition d'un réseau de neurones avec \texttt{PyTorch}}
    
  \href{https://pytorch.org/tutorials/beginner/basics/buildmodel_tutorial.html}{pytorch.org/tutorials/beginner/basics/buildmodel\_tutorial.html}

  \end{frame}


% \begin{frame}{Pour aller plus loin}

%   \textbf{Concept de polymorphisme}
  
%   \href{https://www.w3schools.com/python/python\_polymorphism.asp}{w3schools.com/python/python\_polymorphism}
  
%   \medskip

%   \textbf{Classes abstraites}
  
%   \href{https://peps.python.org/pep-3119/}{peps.python.org/pep-3119}

%   \medskip  

%   \textbf{Classes de données}
  
%   \href{https://docs.python.org/3/library/dataclasses.html}{docs.python.org/3/library/dataclasses}
% \end{frame}


\end{document}